package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:
    private Logger log = Logger.getLogger(getClass());

    public boolean errorDetected;

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
        errorDetected = true;

        StringBuilder msg = new StringBuilder(message);
        if (info instanceof Symbol) {
            msg.append(" na liniji: ").append(((Symbol)info).left);
        }

        log.error(msg.toString());
    }
:}

init with {:
    errorDetected = false;
:}

scan with {:
    Symbol s = this.getScanner().next_token();

    if (s != null && s.value != null) {
        log.info(s.toString() + " " + s.value.toString());
    }

    return s;
:}


terminal PROG, NEW, CONST;
terminal READ, PRINT, RETURN, VOID;
terminal DO, WHILE, BREAK, CONTINUE;
terminal SWITCH, CASE, YIELD, DEFAULT;
terminal ASSIGN, PLUS, MINUS, MULTIPLE, DIVIDE, MODULO, INCREMENT, DECREMENT;
terminal AND, OR, EQ, NEQ, GT, LT, GEQ, LEQ;
terminal SEMI, COMMA, LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET;
terminal NUMBER, CHARLIT, BOOLLIT, IDENT;

nonterminal Program, VarConstDecls, Type;
nonterminal VarConstDecl, VarDeclList, VarDeclMore, VarDecl;
nonterminal ConstDeclList, ConstDeclMore, ConstDecl, ConstValue;
nonterminal MethodDecls, MethodDecl, ReturnType, FormPars, FormPar, FormParMore, MethodVarDecls, Statements;
nonterminal Statement;





Program ::= (Program) PROG IDENT:progName VarConstDecls LBRACE MethodDecls RBRACE
          ;

VarConstDecls ::= (VarConstDeclList) VarConstDecls VarConstDecl
                | (EmptyVarConstDeclList) /* epsilon */
                ;

VarConstDecl ::= (VarConstDeclVar) VarDeclList
               | (VarConstDeclConst) ConstDeclList
               ;

VarDeclList ::= (VarDeclList) Type:varType VarDecl VarDeclMore SEMI
              ;

VarDeclMore ::= (VarDeclMoreElement) COMMA VarDecl VarDeclMore
              | (EmptyVarDeclMore) /* epsilon */
              ;

VarDecl ::= (SingularVarDecl) IDENT:varName
          | (ArrayVarDecl) IDENT:varName LBRACKET RBRACKET
          ;

ConstDeclList ::= (ConstDeclList) CONST Type:varType ConstDecl ConstDeclMore SEMI
                ;

ConstDeclMore ::= (ConstDeclMoreElement) COMMA ConstDecl ConstDeclMore
                | (EmptyConstDeclMore) /* epsilon */
                ;

ConstDecl ::= (ConstDecl) IDENT:constName ASSIGN ConstValue:constValue
            ;

ConstValue ::= (NumConst) NUMBER
             | (CharConst) CHARLIT
             | (BoolConst) BOOLLIT
             ;

MethodDecls ::= (MethodDeclList) MethodDecls MethodDecl
              | (EmptyMethodDeclList) /* epsilon */
              ;

MethodDecl ::= (MethodDecl) ReturnType IDENT LPAREN FormPars RPAREN MethodVarDecls LBRACE Statements RBRACE
              ;

ReturnType ::= (NonVoidReturnType) Type
             | (VoidReturnType) VOID
             ;

FormPars ::= (FormParList) FormPar FormParMore
           | (NoFormPars) /* epsilon */
           ;

FormPar ::= (FormPar) Type:parType VarDecl
          ;

FormParMore ::= (FormParMoreElement) COMMA FormPar FormParMore
              | (EmptyFormParMore) /* epsilon */
              ;

MethodVarDecls ::= (MethodVarDeclList) MethodVarDecls VarDeclList
                 | (EmptyMethodVarDeclList) /* epsilon */
                 ;

Statements ::= (StatementList) Statements Statement
             | (EmptyStatementList) /* epsilon */
             ;

Statement ::= (Statement) PRINT
            ;

Type ::= (Type) IDENT
       ;





