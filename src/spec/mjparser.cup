package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:
    private Logger log = Logger.getLogger(getClass());

    public boolean errorDetected;

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
        errorDetected = true;

        StringBuilder msg = new StringBuilder(message);
        if (info instanceof Symbol) {
            msg.append(" na liniji: ").append(((Symbol)info).left);
        }

        log.error(msg.toString());
    }
:}

init with {:
    errorDetected = false;
:}

scan with {:
    Symbol s = this.getScanner().next_token();

    if (s != null && s.value != null) {
        log.info(s.toString() + " " + s.value.toString());
    }

    return s;
:}


terminal PROG, NEW, CONST;
terminal READ, PRINT, RETURN, VOID;
terminal DO, WHILE, BREAK, CONTINUE, IF, ELSE;
terminal SWITCH, CASE, YIELD, DEFAULT;
terminal ASSIGN, PLUS, MINUS, MULTIPLE, DIVIDE, MODULO, INCREMENT, DECREMENT;
terminal AND, OR, EQ, NEQ, GT, LT, GEQ, LEQ;
terminal COLON, SEMI, COMMA, LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET;
terminal NUMBER, CHARLIT, BOOLLIT;

terminal String IDENT;

nonterminal Program, VarConstDecls;
nonterminal VarConstDecl, VarDecl, VarNames, VarName;
nonterminal ConstDecl, ConstAssigns, ConstAssign, ConstValue;
nonterminal MethodDecls, MethodDecl, ReturnType, FormPars, FormPar, FormParMore, MethodVarDecls, Statements;
nonterminal Statement, Matched, Unmatched, PrintArg, DesignatorStatement, Designator, ActPars, ActParsMore;
nonterminal Expr, Negation, Terms, Term, Factor, Addop, Mulop;
nonterminal Condition, CondTerm, CondFact, Relop;
nonterminal Cases;

nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, MethodTypeName;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type;

Program ::= (Program) PROG ProgName:progName VarConstDecls LBRACE MethodDecls RBRACE
          ;

ProgName ::= (ProgName) IDENT:progName
           ;

VarConstDecls ::= (VarConstDeclList) VarConstDecls VarConstDecl
                | (EmptyVarConstDeclList) /* epsilon */
                ;

VarConstDecl ::= (VarConstDeclVar) VarDecl
               | (VarConstDeclConst) ConstDecl
               ;

VarDecl ::= (VarDeclList) Type:varType VarNames SEMI
          | (VarDeclListError) error SEMI:l
                {: parser.report_error("Losa deklaracija promenljivih na liniji: " + lleft, null); :}
          ;

VarNames ::= (VarNameList) VarNames COMMA VarName
           | (VarNameElement) VarName
           ;

VarName ::= (SingularVarName) IDENT:varName
          | (ArrayVarName) IDENT:varName LBRACKET RBRACKET
          | (VarNameError) error:l
                {: parser.report_error("Lose ime promenljive ili parametra na liniji: " + lleft, null); :}
          ;

ConstDecl ::= (ConstDeclList) CONST Type:varType ConstAssigns SEMI
            | (ConstDeclListError) CONST error SEMI:l
                {: parser.report_error("Losa deklaracija konstanti na liniji: " + lleft, null); :}
            ;

ConstAssigns ::= (ConstAssignList) ConstAssigns COMMA ConstAssign
               | (ConstAssignElement) ConstAssign
               ;

ConstAssign ::= (ConstAssignment) IDENT:constName ASSIGN ConstValue:constValue
              | (ConstAssignError) error:l
                    {: parser.report_error("Losa deklaracija konstante na liniji: " + lleft, null); :}
              ;

ConstValue ::= (NumConst) NUMBER
             | (CharConst) CHARLIT
             | (BoolConst) BOOLLIT
             ;

MethodDecls ::= (MethodDeclList) MethodDecls MethodDecl
              | (EmptyMethodDeclList) /* epsilon */
              ;

MethodDecl ::= (MethodDecl) MethodTypeName LPAREN FormPars RPAREN MethodVarDecls LBRACE Statements RBRACE
              ;

MethodTypeName ::= (MethodTypeName) ReturnType IDENT:methodName
                 ;

ReturnType ::= (NonVoidReturnType) Type
             | (VoidReturnType) VOID
             ;

FormPars ::= (FormParList) FormPar FormParMore
           | (FormParsError) error:l
                {: parser.report_error("Losa deklaracija formalnih parametara na liniji: " + lleft, null); :}
           | (NoFormPars) /* epsilon */
           ;

FormPar ::= (FormPar) Type:parType VarName
          ;

FormParMore ::= (FormParMoreElement) COMMA FormPar FormParMore
              | (EmptyFormParMore) /* epsilon */
              ;

MethodVarDecls ::= (MethodVarDeclList) MethodVarDecls VarDecl
                 | (EmptyMethodVarDeclList) /* epsilon */
                 ;

Statements ::= (StatementList) Statements Statement
             | (EmptyStatementList) /* epsilon */
             ;

Statement ::= (MatchedStmt) Matched
            | (UnmatchedStmt) Unmatched
            ;

Matched ::= (DesignatorStmt) DesignatorStatement SEMI
          | (PrintStmt) PRINT LPAREN Expr PrintArg RPAREN SEMI
          | (ReadStmt) READ LPAREN Designator RPAREN SEMI
          | (ReturnStmt) RETURN Expr SEMI
          | (StatementBlock) LBRACE Statements RBRACE
          | (WhileStmt) DO Statement WHILE LPAREN Condition RPAREN SEMI
          | (BreakStmt) BREAK SEMI
          | (ContinueStmt) CONTINUE SEMI
          | (MatchedIfElseStmt) IF LPAREN Condition RPAREN Matched ELSE Matched
          | (YieldStmt) YIELD Expr SEMI
          ;

Unmatched ::= (UnmatchedIfStmt) IF LPAREN Condition RPAREN Statement
            | (UnmatchedIfElseStmt) IF LPAREN Condition RPAREN Matched ELSE Unmatched
            ;

PrintArg ::= (PrintWidth) COMMA NUMBER:width
           | (NoPrintArg) /* epsilon */
           ;

DesignatorStatement ::= (AssignmentStmt) Designator ASSIGN Expr
                      | (IncrementStmt) Designator INCREMENT
                      | (DecrementStmt) Designator DECREMENT
                      | (MethodCall) Designator LPAREN ActPars RPAREN
                      ;

Designator ::= (SingularDesignator) IDENT:name
             | (ArrayDesignator) IDENT:name LBRACKET Expr:index RBRACKET
             ;

ActPars ::= (ActParList) Expr ActParsMore
          | (NoActPars) /* epsilon */
          ;

ActParsMore ::= (ActParsMoreElement) COMMA Expr ActParsMore
              | (EmptyActParsMore) /* epsilon */
              ;

Type ::= (Type) IDENT:typeName
       ;

Expr ::= (Expression) Negation Terms
       | (SwitchExpr) SWITCH LPAREN Expr RPAREN LBRACE Cases DEFAULT COLON Statements RBRACE
       ;

Cases ::= (CaseList) Cases CASE NUMBER COLON Statements
        | (EmptyCaseListElement) /* epsilon */
        ;

Negation ::= (ExistingNegation) MINUS
           | (NoNegation) /* epsilon */
           ;

Terms ::= (TermList) Terms Addop Term
        | (TermListElement) Term
        ;

Term ::= (FactorList) Term Mulop Factor
       | (FactorTerm) Factor
       ;

Factor ::= (DesignatorFctr) Designator
         | (ConstValueFctr) ConstValue
         | (ExprFctr) LPAREN Expr RPAREN
         | (ArrayInitFctr) NEW Type LBRACKET Expr RBRACKET
         | (MethodCallFctr) Designator LPAREN ActPars RPAREN
         ;

Addop ::= (Plus) PLUS
        | (Minus) MINUS
        ;

Mulop ::= (Multiple) MULTIPLE
        | (Divide) DIVIDE
        | (Modulo) MODULO
        ;

Condition ::= (ConditionList) Condition OR CondTerm
            | (ConditionListElement) CondTerm
            | (ConditionError) error:l
                {: parser.report_error("Los logicki izraz na liniji: " + lleft, null); :}
            ;


CondTerm ::= (CondTermList) CondFact AND CondFact
           | (CondTermElement) CondFact
           ;

CondFact ::= (CondFactList) CondFact Relop Expr
           | (CondFactElement) Expr
           ;

Relop ::= (Equal) EQ
        | (NotEqual) NEQ
        | (GreaterThan) GT
        | (LesserThan) LT
        | (GreaterEqual) GEQ
        | (LesserEqual) LEQ
        ;
